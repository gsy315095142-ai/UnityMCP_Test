# Unity AI 辅助开发插件 - 项目开发计划与进度

**项目名称**: Unity AI 辅助开发插件（UnityMCP）
**项目路径**: C:\Office_Program\UnityTest\UnityMCP_Test
**计划制定日期**: 2026-02-01
**当前阶段**: Phase 0 - 准备阶段
**预计完成日期**: Phase 1 MVP - 2026年3月中旬
**开发模式**: AI Assistant 主导开发，用户管理 Git 同步
**Unity 版本**: 2022.3.13f1c1
**项目类型**: VR 3D 项目

---

## 📋 总体规划概览

### 项目里程碑

| 阶段 | 名称 | 预计时长 | 目标 | 状态 |
|------|------|---------|------|------|
| **Phase 0** | 准备与环境搭建 | 2-3天 | 学习参考项目，理解技术栈 | 🔵 进行中 |
| **Phase 1** | 核心框架 + MVP | 4-5周 | 实现基础代码生成功能 | ⬜ 未开始 |
| **Phase 2** | 功能完善 | 4-5周 | 扩展功能，预制体生成 | ⬜ 未开始 |
| **Phase 3** | 高级功能（可选） | 按需 | MCP Tools、Roslyn等 | ⬜ 未开始 |
| **Phase 4** | 优化与发布 | 2-3周 | 性能优化，文档完善 | ⬜ 未开始 |

### 关键指标

- **代码行数目标**: Phase 1 约 3000-5000 行
- **测试覆盖率**: 核心功能 >70%
- **代码质量**: 每个公共 API 都有文档
- **文件管理**: 所有文件在项目文件夹中创建，由用户同步到 Git

### VR 项目特殊考虑

本项目目标平台为 VR 3D，在代码生成时会考虑以下 VR 相关因素：

- **性能优化**: VR 对帧率要求极高（90+ FPS），生成的代码将注重性能
- **常用 VR 组件**: 在 Prompt 模板中包含 VR 常用组件（XR Interaction、Teleportation 等）
- **XR SDK**: 支持生成与 Unity XR Toolkit 兼容的代码
- **交互模式**: 优先生成适合 VR 交互的脚本（射线交互、抓取、传送等）
- **优化建议**: Phase 2 可以添加 VR 性能优化提示（Draw Call、GC 优化等）

**注**: Phase 1 MVP 阶段先实现通用功能，VR 特定优化在 Phase 2-3 逐步加入

---

## 🚀 Phase 0: 准备与环境搭建（2-3天）

**目标**: 学习必要的技术栈和参考项目

### 任务清单

#### Day 1: 学习参考项目核心代码

- [x] **Unity-MCP 核心代码阅读**（3-4小时）
  - [x] 阅读 `MainThread.cs` - 理解主线程调度机制
  - [x] 阅读 `GameObjectRef.cs` - 理解对象引用系统
  - [x] 阅读 `Script.Execute.cs` - 了解 Roslyn 动态编译（Phase 3 可选）
  - [x] 记录关键设计模式和技巧
  - [x] 提取可复用的代码片段

- [x] **AI API 学习**（2小时）
  - [x] 阅读 Claude API 官方文档
  - [x] 了解 Messages API 使用方法
  - [x] 学习 Prompt 工程基础
  - [x] 理解不同 AI API 的差异（Claude vs OpenAI）

#### Day 2-3: 技术验证和项目结构设计

- [ ] **技术原型验证**（半天）
  - [ ] 创建简单的 EditorWindow 原型
  - [ ] 测试 Unity 中的 HTTP 请求（UnityWebRequest）
  - [ ] 验证 async/await 在 Unity Editor 中的使用
  - [ ] 测试 EditorPrefs 存储和加密

- [ ] **项目结构设计**（半天）
  - [ ] 创建项目文件夹结构
  - [ ] 创建 Assembly Definition Files
  - [ ] 设置命名空间规范（UnityMCP.{模块}）
  - [ ] 创建基础的文件夹和文件模板

### 交付成果

- ✅ 已完成参考项目学习，提取关键代码
- ✅ 已了解 Claude API 和其他 AI API
- [ ] 技术原型验证通过
- [ ] 项目结构已搭建

---

## 🎯 Phase 1: 核心框架 + MVP（4-5周）

**目标**: 实现最小可用版本，用户可以在 Unity 中输入需求，自动生成代码

**开发说明**:
- 所有代码文件将在项目文件夹中创建和更新
- 用户负责将文件同步到 Git
- 我将提供完整的代码实现，用户可以直接使用

### Week 1: 核心工具层（5天）

#### Day 1-2: MainThread 主线程调度器

- [ ] **设计与实现**（1.5天）
  - [ ] 创建 `Assets/Editor/UnityMCP/Core/MainThread.cs`
  - [ ] 实现单例模式
  - [ ] 实现 `Run<T>(Func<T> action)` 方法
  - [ ] 使用 `TaskCompletionSource` 同步
  - [ ] 实现 `RunAsync<T>(Func<Task<T>> action)` 方法
  - [ ] 处理异常和超时

- [ ] **测试**（0.5天）
  - [ ] 创建测试脚本验证功能
  - [ ] 测试多线程调用
  - [ ] 测试异常处理
  - [ ] 性能测试

```csharp
// 预期实现示例
public class MainThread : MonoBehaviour
{
    private static MainThread _instance;
    public static MainThread Instance
    {
        get
        {
            if (_instance == null)
            {
                var go = new GameObject("MainThread");
                _instance = go.AddComponent<MainThread>();
                DontDestroyOnLoad(go);
            }
            return _instance;
        }
    }

    public T Run<T>(Func<T> action)
    {
        var tcs = new TaskCompletionSource<T>();
        // 调度到主线程执行
        // ...
        return tcs.Task.Result;
    }
}
```

#### Day 3-4: GameObjectRef 引用系统

- [ ] **设计与实现**（1.5天）
  - [ ] 创建 `GameObjectRef.cs`
  - [ ] 实现多种定位方式（scenePath, hierarchyPath, instanceId）
  - [ ] 实现 `FindGameObject(out string error)` 方法
  - [ ] 处理对象不存在的情况
  - [ ] 支持序列化

- [ ] **测试**（0.5天）
  - [ ] 测试各种引用方式
  - [ ] 测试错误处理
  - [ ] 测试序列化/反序列化

#### Day 5: ProjectContext 项目上下文

- [ ] **设计与实现**（1天）
  - [ ] 创建 `ProjectContext.cs`
  - [ ] 收集 Unity 版本信息
  - [ ] 收集命名空间规范
  - [ ] 扫描现有脚本列表
  - [ ] 收集代码风格配置
  - [ ] 生成上下文信息用于 Prompt

```csharp
public class ProjectContext
{
    public string UnityVersion { get; set; }
    public string DefaultNamespace { get; set; }
    public List<string> ExistingScripts { get; set; }
    public CodeStyleConfig CodeStyle { get; set; }

    public string ToPromptContext()
    {
        // 生成用于 AI Prompt 的上下文字符串
    }
}
```

**Week 1 里程碑**: 核心工具层完成，可以在主线程执行操作，可以引用 GameObject

---

### Week 2: AI 服务层（5天）

#### Day 1-2: IAIService 接口和 AIServiceConfig

- [ ] **接口设计**（0.5天）
  - [ ] 创建 `IAIService.cs` 接口
  - [ ] 定义 `GenerateCode()` 方法
  - [ ] 定义 `GeneratePrefab()` 方法（Phase 2）
  - [ ] 定义错误处理接口

- [ ] **配置系统**（1天）
  - [ ] 创建 `AIServiceConfig.cs`
  - [ ] 实现配置序列化
  - [ ] 实现 API Key 加密存储
  - [ ] 创建配置 ScriptableObject

- [ ] **测试**（0.5天）
  - [ ] 测试配置保存和加载
  - [ ] 测试 API Key 加密/解密

#### Day 3-4: ClaudeService 实现

- [ ] **核心实现**（1.5天）
  - [ ] 创建 `ClaudeService.cs`
  - [ ] 实现 HTTP 请求（使用 UnityWebRequest）
  - [ ] 实现异步调用
  - [ ] 处理 API 响应
  - [ ] 错误处理和重试机制
  - [ ] 超时处理

- [ ] **测试**（0.5天）
  - [ ] 测试 API 调用
  - [ ] 测试错误处理
  - [ ] 测试超时重试

```csharp
public class ClaudeService : IAIService
{
    private string apiKey;
    private string model = "claude-3-5-sonnet-20241022";

    public async Task<string> GenerateCode(string prompt, ProjectContext context)
    {
        var fullPrompt = PromptBuilder.BuildCodePrompt(prompt, context);

        var requestBody = new
        {
            model = model,
            max_tokens = 4000,
            messages = new[]
            {
                new { role = "user", content = fullPrompt }
            }
        };

        // 调用 Claude API
        var response = await CallAPI(requestBody);
        return ResponseParser.ParseCodeResponse(response);
    }
}
```

#### Day 5: AIServiceFactory

- [ ] **工厂模式实现**（1天）
  - [ ] 创建 `AIServiceFactory.cs`
  - [ ] 实现服务创建逻辑
  - [ ] 支持多种 AI 服务商切换
  - [ ] 单例和缓存管理

**Week 2 里程碑**: AI 服务层完成，可以调用 Claude API 生成代码

---

### Week 3: Prompt 和解析器（5天）

#### Day 1-3: PromptBuilder 构建器

- [ ] **设计 Prompt 模板**（1天）
  - [ ] 设计系统 Prompt
  - [ ] 设计代码生成 Prompt
  - [ ] 设计输出格式（JSON Schema）
  - [ ] 添加示例（Few-shot learning）

- [ ] **实现 PromptBuilder**（1.5天）
  - [ ] 创建 `PromptBuilder.cs`
  - [ ] 实现 `BuildCodePrompt()` 方法
  - [ ] 注入项目上下文
  - [ ] 注入代码风格规范
  - [ ] 优化 Prompt 长度

- [ ] **测试和优化**（0.5天）
  - [ ] 测试不同场景的 Prompt
  - [ ] 优化 Prompt 效果
  - [ ] 记录 token 使用量

```csharp
public class PromptBuilder
{
    public static string BuildCodePrompt(string userRequest, ProjectContext context)
    {
        return $@"
You are a Unity C# code generator. Generate high-quality code based on user requirements.

## Project Context
- Unity Version: {context.UnityVersion}
- Namespace: {context.DefaultNamespace}
- Code Style: {context.CodeStyle}

## User Request
{userRequest}

## Output Format (JSON)
{{
  ""scriptName"": ""ClassName"",
  ""namespace"": ""ProjectName.Module"",
  ""code"": ""complete C# code here""
}}

Generate clean, well-documented Unity C# code following best practices.";
    }
}
```

#### Day 4-5: ResponseParser 解析器

- [ ] **实现解析器**（1.5天）
  - [ ] 创建 `ResponseParser.cs`
  - [ ] 解析 JSON 响应
  - [ ] 提取代码内容
  - [ ] 验证响应格式
  - [ ] 错误处理

- [ ] **测试**（0.5天）
  - [ ] 测试各种响应格式
  - [ ] 测试错误响应处理
  - [ ] 测试边界情况

**Week 3 里程碑**: Prompt 和解析系统完成，AI 可以返回结构化的代码

---

### Week 4: UI 层和生成器（5天）

#### Day 1-2: SettingsWindow AI配置窗口

- [ ] **UI 设计**（0.5天）
  - [ ] 设计窗口布局
  - [ ] 设计表单元素
  - [ ] 设计用户交互流程

- [ ] **实现**（1天）
  - [ ] 创建 `SettingsWindow.cs`
  - [ ] 继承 `EditorWindow`
  - [ ] 实现 UI 绘制（OnGUI）
  - [ ] 实现配置保存
  - [ ] 实现连接测试功能

- [ ] **测试**（0.5天）
  - [ ] 测试配置保存和加载
  - [ ] 测试连接测试功能
  - [ ] 测试 UI 交互

#### Day 3-4: AIQuickCommand 快捷输入

- [ ] **实现**（1.5天）
  - [ ] 创建 `AIQuickCommand.cs`
  - [ ] 实现快捷键注册（Ctrl+Shift+G）
  - [ ] 实现输入框 UI
  - [ ] 集成 AI 服务调用
  - [ ] 实现进度显示
  - [ ] 错误提示

- [ ] **测试**（0.5天）
  - [ ] 测试快捷键触发
  - [ ] 测试 AI 调用流程
  - [ ] 测试错误处理

```csharp
public class AIQuickCommand : EditorWindow
{
    [MenuItem("Tools/AI Generate %#g")] // Ctrl+Shift+G
    public static void ShowWindow()
    {
        var window = GetWindow<AIQuickCommand>();
        window.titleContent = new GUIContent("AI Generate");
        window.ShowPopup();
    }

    private string userInput = "";

    void OnGUI()
    {
        userInput = EditorGUILayout.TextField("Describe:", userInput);

        if (Event.current.type == EventType.KeyDown &&
            Event.current.keyCode == KeyCode.Return)
        {
            GenerateWithAI(userInput);
            Close();
        }
    }
}
```

#### Day 5: ScriptGenerator 代码生成器

- [ ] **模板系统**（0.5天）
  - [ ] 创建 MonoBehaviour 模板
  - [ ] 创建模板变量替换系统

- [ ] **实现生成器**（0.5天）
  - [ ] 创建 `ScriptGenerator.cs`
  - [ ] 实现模板填充
  - [ ] 实现代码格式化
  - [ ] 实现文件写入

**Week 4 里程碑**: UI 和生成器完成，用户可以输入需求并生成代码文件

---

### Week 5: 集成和测试（5天）

#### Day 1-2: 端到端集成

- [ ] **完整流程集成**（1.5天）
  - [ ] 连接所有模块
  - [ ] 实现完整的工作流
  - [ ] PreviewWindow 预览窗口实现
  - [ ] 用户确认流程

- [ ] **错误处理优化**（0.5天）
  - [ ] 统一错误处理
  - [ ] 用户友好的错误提示
  - [ ] 日志记录

#### Day 3-4: 测试

- [ ] **功能测试**（1天）
  - [ ] 测试完整流程
  - [ ] 测试各种边界情况
  - [ ] 测试错误恢复
  - [ ] 性能测试

- [ ] **用户测试**（1天）
  - [ ] 内部用户测试
  - [ ] 收集反馈
  - [ ] 修复 Bug

#### Day 5: 文档和优化

- [ ] **文档**（0.5天）
  - [ ] 编写用户文档
  - [ ] 编写开发者文档
  - [ ] 代码注释完善

- [ ] **优化**（0.5天）
  - [ ] 性能优化
  - [ ] UI 优化
  - [ ] 代码重构

### Phase 1 交付成果

- ✅ 用户可以按 Ctrl+Shift+G 输入需求
- ✅ 系统调用 Claude API 生成代码
- ✅ 生成的代码显示在预览窗口
- ✅ 用户确认后保存到项目
- ✅ Unity 自动编译新脚本
- ✅ 基础文档完成

**Phase 1 里程碑**: MVP 完成，可以演示基础功能！

---

## 🔧 Phase 2: 功能完善（4-5周）

**目标**: 扩展功能，支持预制体生成和更多代码类型

### Week 6-7: 扩展 AI 服务和代码类型

- [ ] **OpenAIService 实现**（3天）
  - [ ] 实现 OpenAI API 集成
  - [ ] 支持 GPT-4o
  - [ ] 测试和优化

- [ ] **ScriptableObject 模板**（2天）
  - [ ] 创建 ScriptableObject 模板
  - [ ] 扩展 ScriptGenerator
  - [ ] 测试生成 ScriptableObject

- [ ] **Manager 单例模板**（2天）
  - [ ] 创建 Manager 模板
  - [ ] 实现单例模式
  - [ ] 测试

- [ ] **代码风格优化**（3天）
  - [ ] 支持多种代码风格
  - [ ] 代码格式化
  - [ ] 命名冲突检测

### Week 8-9: 预制体生成

- [ ] **PrefabGenerator 实现**（5天）
  - [ ] 设计预制体生成流程
  - [ ] 实现 GameObject 层级创建
  - [ ] 实现 Component 添加
  - [ ] 实现属性配置
  - [ ] 保存为 Prefab

- [ ] **Component 配置系统**（3天）
  - [ ] 实现常用 Component 配置
  - [ ] 支持自定义配置
  - [ ] 测试

- [ ] **UI 预制体支持**（2天）
  - [ ] 支持 UGUI 组件
  - [ ] Button, Panel, InputField 等
  - [ ] 测试

### Week 10: 优化和完善

- [ ] **AIAssistantWindow 完整窗口**（3天）
  - [ ] 设计完整窗口
  - [ ] 历史记录功能
  - [ ] 高级参数配置

- [ ] **错误处理和日志**（1天）
  - [ ] 完善错误处理
  - [ ] 日志系统
  - [ ] 错误上报

- [ ] **性能优化**（1天）
  - [ ] 异步优化
  - [ ] 缓存优化
  - [ ] UI 响应优化

### Phase 2 交付成果

- ✅ 支持多个 AI 服务商（Claude + OpenAI）
- ✅ 支持多种代码类型（MonoBehaviour + ScriptableObject + Manager）
- ✅ 可以生成预制体
- ✅ 完整的 AI Assistant 窗口
- ✅ 错误处理完善

**Phase 2 里程碑**: 功能完善，可以实际使用！

---

## 🚀 Phase 3: 高级功能（按需，可选）

### MCP Tools 模式支持（2-3周）

- [ ] **MCP Tools 实现**
  - [ ] 集成 Unity-MCP-Server
  - [ ] 实现 Tool 定义
  - [ ] 测试 MCP 协议

### Roslyn 动态编译（1-2周）

- [ ] **Roslyn 集成**
  - [ ] 代码动态编译
  - [ ] 语法检查
  - [ ] 即时执行

### 本地模型支持（1周）

- [ ] **LocalLMService 实现**
  - [ ] 支持 Ollama
  - [ ] 支持 LM Studio
  - [ ] 测试

---

## ⚠️ 风险管理

### 技术风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| AI API 调用失败 | 高 | 中 | 实现重试机制，错误提示 |
| Unity 主线程调用问题 | 高 | 低 | 参考 Unity-MCP 实现 |
| API Key 安全问题 | 中 | 中 | 加密存储，不提交代码 |
| 代码生成质量不佳 | 中 | 中 | 优化 Prompt，提供预览 |
| 性能问题（大项目） | 低 | 低 | 异步处理，缓存优化 |

### 时间风险

| 风险 | 缓解措施 |
|------|---------|
| 学习曲线过陡 | 提前学习参考项目，技术原型验证 |
| 功能蔓延 | 严格按照 MVP 原则，Phase 1 只做核心功能 |
| Bug 修复时间长 | 每日测试，及时修复，不积压 Bug |

---

## 📊 进度跟踪

### 当前进度

**Phase 0**: 🔵 进行中（已完成参考项目分析）
**完成度**: 约30%
**下一步**: 完成技术验证，创建项目结构

### 开发模式说明

**AI Assistant 主导开发**:
- 我（AI Assistant）负责编写所有代码和文档
- 所有文件在项目文件夹 `C:\Office_Program\UnityTest\UnityMCP_Test` 中创建
- 用户负责将文件同步到 Git 仓库
- 用户可以随时提出需求调整和反馈

### 开发节奏

**Phase 0-1 期间**:
- 按照计划逐步实现各个模块
- 完成一个模块后汇报并征求反馈
- 根据测试结果调整实现方案

**关键检查点**:
1. Phase 0 完成后：确认项目结构和技术栈
2. Week 1 完成后：验证核心工具层可用性
3. Week 2 完成后：验证 AI 服务层可以成功调用 API
4. Week 3 完成后：验证 Prompt 和解析系统
5. Week 4-5 完成后：端到端测试 MVP

---

## 📝 开发规范

### 代码规范

- **命名约定**: PascalCase（类、方法）+ camelCase（字段）
- **注释**: 所有公共 API 必须有 XML 文档注释
- **命名空间**: UnityMCP.{模块名}

### Git 规范

**注**: Git 管理由用户负责，以下为建议规范：

- **分支策略**: main + develop + feature/*（用户自行决定）
- **提交信息建议**:
  - feat: 新功能
  - fix: Bug 修复
  - docs: 文档更新
  - refactor: 重构
  - test: 测试

### 代码质量标准

- 核心功能必须经过测试验证
- 所有公共 API 必须有文档注释
- 不允许提交注释掉的代码

---

## 🎯 成功标准

### Phase 1 MVP 成功标准

1. ✅ 用户可以在 Unity 中按快捷键输入需求
2. ✅ 系统成功调用 Claude API
3. ✅ 生成的代码可以编译通过
4. ✅ 生成的代码符合基本规范
5. ✅ 错误处理友好
6. ✅ 有基础文档

### Phase 2 成功标准

1. ✅ 支持多个 AI 服务商
2. ✅ 可以生成预制体
3. ✅ 支持多种代码类型
4. ✅ 性能良好（响应时间 < 10秒）
5. ✅ 稳定性好（错误率 < 5%）

---

## 📅 关键日期

- **2026-02-01**: 项目启动，Phase 0 开始
- **2026-02-06**: Phase 0 完成，Phase 1 开始
- **2026-03-13**: Phase 1 MVP 完成（预计）
- **2026-04-17**: Phase 2 完成（预计）

---

**文档维护**: 每周五更新进度，记录问题和解决方案
